{"ast":null,"code":"import { multiaddr } from '@multiformats/multiaddr';\nconst reduceValue = (_, v) => v;\nconst tcpUri = (str, port, parts, opts) => {\n  // return tcp when explicitly requested\n  if (opts != null && opts.assumeHttp === false) return `tcp://${str}:${port}`;\n  // check if tcp is the last protocol in multiaddr\n  let protocol = 'tcp';\n  let explicitPort = `:${port}`;\n  const last = parts[parts.length - 1];\n  if (last.protocol === 'tcp') {\n    // assume http and produce clean urls\n    protocol = port === '443' ? 'https' : 'http';\n    explicitPort = port === '443' || port === '80' ? '' : explicitPort;\n  }\n  return `${protocol}://${str}${explicitPort}`;\n};\nconst Reducers = {\n  ip4: reduceValue,\n  ip6: (str, content, i, parts) => parts.length === 1 && parts[0].protocol === 'ip6' ? content : `[${content}]`,\n  tcp: (str, content, i, parts, opts) => parts.some(p => ['http', 'https', 'ws', 'wss'].includes(p.protocol)) ? `${str}:${content}` : tcpUri(str, content, parts, opts),\n  udp: (str, content) => `udp://${str}:${content}`,\n  dnsaddr: reduceValue,\n  dns4: reduceValue,\n  dns6: reduceValue,\n  ipfs: (str, content) => `${str}/ipfs/${content}`,\n  p2p: (str, content) => `${str}/p2p/${content}`,\n  http: str => `http://${str}`,\n  https: str => `https://${str}`,\n  ws: str => `ws://${str}`,\n  wss: str => `wss://${str}`,\n  'p2p-websocket-star': str => `${str}/p2p-websocket-star`,\n  'p2p-webrtc-star': str => `${str}/p2p-webrtc-star`,\n  'p2p-webrtc-direct': str => `${str}/p2p-webrtc-direct`\n};\nexport function multiaddrToUri(input, opts) {\n  const ma = multiaddr(input);\n  const parts = ma.toString().split('/').slice(1);\n  return ma.tuples().map(tuple => ({\n    protocol: parts.shift() ?? '',\n    content: tuple[1] != null ? parts.shift() ?? '' : ''\n  })).reduce((str, part, i, parts) => {\n    const reduce = Reducers[part.protocol];\n    if (reduce == null) {\n      throw new Error(`Unsupported protocol ${part.protocol}`);\n    }\n    return reduce(str, part.content, i, parts, opts);\n  }, '');\n}","map":{"version":3,"mappings":"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","names":["multiaddr","reduceValue","_","v","tcpUri","str","port","parts","opts","assumeHttp","protocol","explicitPort","last","length","Reducers","ip4","ip6","content","i","tcp","some","p","includes","udp","dnsaddr","dns4","dns6","ipfs","p2p","http","https","ws","wss","multiaddrToUri","input","ma","toString","split","slice","tuples","map","tuple","shift","reduce","part","Error"],"sources":["/Users/harshatolani/Downloads/Fall22/Distributed Database System/Project/my branch/fair_artist_yt/node_modules/@multiformats/multiaddr-to-uri/src/index.ts"],"sourcesContent":["import type { Multiaddr } from '@multiformats/multiaddr'\nimport { multiaddr } from '@multiformats/multiaddr'\n\nexport interface MultiaddrToUriOpts {\n  assumeHttp?: boolean\n}\n\ninterface Reducer { (str: string, content: string, i: number, parts: Part[], opts?: MultiaddrToUriOpts): string }\n\nconst reduceValue: Reducer = (_, v) => v\nconst tcpUri = (str: string, port: string, parts: Part[], opts?: MultiaddrToUriOpts) => {\n  // return tcp when explicitly requested\n  if ((opts != null) && opts.assumeHttp === false) return `tcp://${str}:${port}`\n  // check if tcp is the last protocol in multiaddr\n  let protocol = 'tcp'\n  let explicitPort = `:${port}`\n  const last = parts[parts.length - 1]\n  if (last.protocol === 'tcp') {\n    // assume http and produce clean urls\n    protocol = port === '443' ? 'https' : 'http'\n    explicitPort = port === '443' || port === '80' ? '' : explicitPort\n  }\n  return `${protocol}://${str}${explicitPort}`\n}\n\nconst Reducers: Record<string, Reducer> = {\n  ip4: reduceValue,\n  ip6: (str, content, i, parts) => (\n    parts.length === 1 && parts[0].protocol === 'ip6'\n      ? content\n      : `[${content}]`\n  ),\n  tcp: (str, content, i, parts, opts) => (\n    parts.some(p => ['http', 'https', 'ws', 'wss'].includes(p.protocol))\n      ? `${str}:${content}`\n      : tcpUri(str, content, parts, opts)\n  ),\n  udp: (str, content) => `udp://${str}:${content}`,\n  dnsaddr: reduceValue,\n  dns4: reduceValue,\n  dns6: reduceValue,\n  ipfs: (str, content) => `${str}/ipfs/${content}`,\n  p2p: (str, content) => `${str}/p2p/${content}`,\n  http: str => `http://${str}`,\n  https: str => `https://${str}`,\n  ws: str => `ws://${str}`,\n  wss: str => `wss://${str}`,\n  'p2p-websocket-star': str => `${str}/p2p-websocket-star`,\n  'p2p-webrtc-star': str => `${str}/p2p-webrtc-star`,\n  'p2p-webrtc-direct': str => `${str}/p2p-webrtc-direct`\n}\n\ninterface Part {\n  protocol: string\n  content: string\n}\n\nexport function multiaddrToUri (input: Multiaddr | string | Uint8Array, opts?: MultiaddrToUriOpts) {\n  const ma = multiaddr(input)\n  const parts = ma.toString().split('/').slice(1)\n  return ma\n    .tuples()\n    .map(tuple => ({\n      protocol: parts.shift() ?? '',\n      content: (tuple[1] != null) ? parts.shift() ?? '' : ''\n    }))\n    .reduce((str: string, part: Part, i: number, parts: Part[]) => {\n      const reduce = Reducers[part.protocol]\n      if (reduce == null) {\n        throw new Error(`Unsupported protocol ${part.protocol}`)\n      }\n      return reduce(str, part.content, i, parts, opts)\n    }, '')\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}